\section{Resources}

Resources are data files that are needed by some application, and that are more or less static.
(So normal input files are not reources) Think of icons, images, configuration files, etcetera.
The main problem with resources is to store them in a place where the application can find them, in particular when 
it is \emph{not} running on the system of the developer of the application, including webstart based deployment.
So, using absolute file paths like:\\
\verb#   C:\myjavaapps\projectXYZ\data\config.xml#,\\
referring to some absolute directory on your hard disk is a bad idea.  
Relative pathes like \verb#../data/config.xml# are somewhat better, since you can relocate your project as a whole, including the data.
But it still cannot handle web deployment, for instance via Java web start.
A better solution is to place resource data in some place that can be found by Java method like ``\verb#getResourceAsStream#''.
Such methods search for resource directories on the Java classpath. In particular, when an application 
runs from a \verb#jar# file, that \verb#jar# file is (automatically) on the classpath. 
This leads to the following solution:
\begin{itemize}
\item A project must have a \verb#resource# (sub)directory, alongside subdirectories like \verb#src#, etcetera.
\item The \verb#resource# directory must occur on the class path when running the project's applications.
\item The contents of the \verb#resource# directory will be packaged within the project's \verb#jar# file, 
together with the \verb#class# files.
\item Resource files will be read exclusively via methods like \verb#getResourceAsStream#.
\end{itemize}

The \verb#hmi.util# package includes a few helper classes for applying this pattern.

\subsection{Quick solutions}
\begin{itemize}

\item Put resource file like ``\verb#config.xml#'' in your project's \verb#resource# director, 
and create a \verb#hmi.util.Resource# object in your application like so:\\
\verb#Resources res = new Resources("");#\\
Then, read your config file for instance with:\\
\verb#String configText = res.read("config.xml");#\\
Often it is better to open a Java \verb#Reader# for some resource, with:\\
\verb#BufferedReader configReader = res.getReader("config.xml");#\\
or, when you need an \verb#InputStream# rather than a \verb#Reader#:\\
\verb#BufferedInputStream ips = res.getInputStream("config.xml");#\\


\end{itemize}



\subsection{hmi.util.Resources}

The \verb#Resources# class is used for more easily loading resources from some resource directory.
To make this more clear, you should understand how the Java methods like \verb#getResourceAsStream# search for resource files:
\begin{itemize}
\item First, you have a number of directories that are present on the Java runtime classpath. For instance, our \verb#ant# build files
ensure that (by default) the project's \verb#resource# subdirectory is always on the classpath.
A second \verb#ant# property called \verb#resource.path#, which is usually set in the \verb#build.properties# file when necessary,
includes more directories on the runtime classpath. For example, a line like:\\
\verb#   resource.path=\${shared.repository}/Humanoids#\\
will include the \verb#Humanoids# directory from our shared repository on the classpath.
\item The directories on the runtime classpath do not usually contain resource files themselves;
rather, one defines subdirectories where the real resource reside. This is often necessary to avoid confusion: if some
file like ``config.xml'' occurs at several places, that happen to be all on the classpath, it becomes unclear
which one will actually be used. 
\item Therefore, the preferred method is to create a separate \verb#hmi.util.Resources# object for every single resource directory
by specifying the local directory name within one of the classpath directories. 
Of course, that directory name should not occur twice within the classpath directories. 
 For example, with  the \verb#resource# directory and the  \verb#\${shared.repository}/Humanoids# on the classpath
 we might have a local resource directories called  ``\verb#icons#'' and ``\verb#shaders#''
  within the project's \verb#resource# directory, and resource directories like  ``\verb#armandia/dae#'' and
  ``\verb#armandia/shaders#'' within \\ \verb#\${shared.repository}/Humanoids#.
  For each of these four directories, we then define a \verb#Resource# object, for example:
  \begin{itemize}
  \item \verb#Resources icons = new Resources("icons")#, referring to the project's \verb#resource/icons# directory.
  \item \verb#Resources projectshaders = new Resources("shaders")#, referring to the project's \verb#resource/shaders# directory.
  \item \verb#Resources model = new Resources("armandia/dae")#, referring to the \verb#armandia/dae# directory within
  the \verb#${shared.repository}/Humanoids# directory.
  \item \verb#Resources modelShaders = new Resources("armandia/shaders")#, referring to the \verb#armandia/shaders# directory within
  the same \\ \verb#${shared.repository}/Humanoids# directory.
  \end{itemize}
\end{itemize}

\subsection{hmi.utl.ResourcePool}

The \verb#hmi.util.Resourc# class is fine for loading resources from a resource directory, but does not take care
of \emph{ resource caching}. That is, when you load, for instance, some  texture image via a \verb#Resource# object, 
you might easily load the same texture image several times. 
Even worse, you might create several different  \verb#GLTexture# objects, all based on the same texture image, resulting in
wasting texture memory space of your graphics card. The \verb#ResourcePool# class has been designed to handle such situations.
A \verb#ResourcePool# object requires you to create a so called ``\verb#ResourceLoader#'' object, to be used when some resource has to be actually loaded from a resource file. The \verb#ResourcePool# will then cache the result, and deliver the cached object
the next time that the same resource is asked for. 





